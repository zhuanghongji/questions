# Atomic、synchronized、volatile 之间的区别

## 自答

`volatile` 可以保证在一个线程的工作内存中修改了该变量的值，该变量的值立即能回显到主内存中，从而保证所有的线程看到这个变量的值是一致的。但是有个前提，因为它不具有操作的原子性，也就是它不适合在对该变量的写操作依赖于变量本身自己。就比如 `i++`、`i += 1;` 这种。但是可以改为 `num = i + 1;` 如果 `i` 是一个 `volatile `类型，那么 `num` 就是安全的，总之就是不能作用于自身。

`synchronized` 是基于代码块的，只要包含在 `synchronized `块中，就是线程安全的。

既然都说了线程安全，就多了解几个：

`AtomicInteger`，一个轻量级的 `synchronized`。使用的并不是同步代码块，而是 Lock-Free 算法(我也不懂，看代码就是一个死循环调用了底层的比较方法直到相同后才退出循环)。最终的结果就是在高并发的时候，或者说竞争激烈的时候效率比 `synchronized` 高一些。

`ThreadLocal`，线程中私有数据。主要用于线程改变内部的数据时不影响其他线程，使用时需要注意 `static`。